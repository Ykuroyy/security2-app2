export interface Topic {
  id: string
  title: string
  content: {
    overview: string
    details: string[]
    examples?: {
      title: string
      code?: string
      explanation: string
    }[]
    keyPoints: string[]
  }
  quiz: {
    id: string
    question: string
    options: string[]
    correctAnswer: number
    explanation: string
  }[]
}

export const topicsData: Record<string, Topic> = {
  'programming-basics': {
    id: 'programming-basics',
    title: 'プログラミング言語とは',
    content: {
      overview: 'プログラミング言語は、人間がコンピュータに対して指示を与えるための言語です。人間が理解しやすい形式で書かれたプログラムを、コンピュータが理解できる機械語に変換することで、様々な処理を実行させることができます。',
      details: [
        '【低水準言語と高水準言語】\n低水準言語（機械語、アセンブリ言語）は、コンピュータのハードウェアに近い言語で、実行速度は速いが人間には理解しにくいという特徴があります。一方、高水準言語（C、Java、Python等）は、人間が理解しやすい形式で記述でき、生産性が高いという利点があります。',
        '【プログラミングパラダイム】\n手続き型プログラミング：処理を順番に記述していく方式（C言語など）\nオブジェクト指向プログラミング：データと処理をオブジェクトとしてまとめる方式（Java、C++など）\n関数型プログラミング：関数の組み合わせで処理を記述する方式（Haskell、Lispなど）',
        '【インタプリタとコンパイラ】\nインタプリタ方式：プログラムを1行ずつ解釈しながら実行する方式。デバッグが容易だが実行速度は遅い（Python、JavaScript等）\nコンパイラ方式：プログラム全体を機械語に変換してから実行する方式。実行速度は速いがデバッグに時間がかかる（C、C++等）',
        '【プログラミング言語の選択基準】\n・処理速度の要求\n・開発効率\n・保守性\n・学習コスト\n・ライブラリやフレームワークの充実度\n・実行環境の制約'
      ],
      examples: [
        {
          title: '同じ処理を異なる言語で記述した例',
          code: `// C言語
#include <stdio.h>
int main() {
    printf("Hello, World!\\n");
    return 0;
}

# Python
print("Hello, World!")

// Java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}`,
          explanation: '同じ"Hello, World!"を出力する処理でも、言語によって記述方法が大きく異なります。Pythonが最も簡潔で、Javaが最も記述量が多くなっています。'
        }
      ],
      keyPoints: [
        'プログラミング言語は人間とコンピュータの橋渡しをする',
        '高水準言語は人間に理解しやすく、低水準言語は機械に近い',
        'コンパイラ方式は実行速度が速く、インタプリタ方式は開発効率が高い',
        '用途に応じて適切なプログラミング言語を選択することが重要'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: '高水準言語の特徴として適切なものはどれか。',
        options: [
          '機械語に近く、実行速度が速い',
          '人間が理解しやすく、生産性が高い',
          'ハードウェアを直接制御できる',
          'メモリ管理を細かく制御できる'
        ],
        correctAnswer: 1,
        explanation: '高水準言語は人間が理解しやすい形式で記述でき、開発の生産性が高いという特徴があります。機械語に近いのは低水準言語の特徴です。'
      },
      {
        id: 'q2',
        question: 'インタプリタ方式の特徴として適切でないものはどれか。',
        options: [
          'プログラムを1行ずつ解釈しながら実行する',
          'デバッグが容易である',
          '実行速度が速い',
          '対話的な実行が可能'
        ],
        correctAnswer: 2,
        explanation: 'インタプリタ方式は1行ずつ解釈しながら実行するため、実行速度は遅くなります。実行速度が速いのはコンパイラ方式の特徴です。'
      }
    ]
  },
  'compiler': {
    id: 'compiler',
    title: 'コンパイラ方式でのプログラム実行手順',
    content: {
      overview: 'コンパイラ方式では、ソースコードを機械語に変換（コンパイル）してから実行します。この過程には複数の段階があり、各段階で異なる処理が行われます。',
      details: [
        '【プログラム実行までの流れ】\n1. ソースコードの作成：プログラマが高水準言語でプログラムを記述\n2. プリプロセス：マクロの展開やインクルードファイルの取り込み\n3. コンパイル：ソースコードをアセンブリ言語に変換\n4. アセンブル：アセンブリ言語を機械語（オブジェクトコード）に変換\n5. リンク：複数のオブジェクトファイルとライブラリを結合\n6. 実行：実行可能ファイルをメモリにロードして実行',
        '【字句解析と構文解析】\n字句解析（レキシカル解析）：ソースコードを最小単位（トークン）に分解する処理。予約語、識別子、演算子、リテラルなどを認識します。\n構文解析（シンタックス解析）：トークンの並びが文法規則に従っているかを確認し、構文木を生成します。',
        '【意味解析と最適化】\n意味解析：変数の型チェック、スコープの確認など、プログラムの意味的な正しさを検証します。\n最適化：実行速度の向上やメモリ使用量の削減を目的として、コードを改善します。不要な処理の削除、ループの展開、定数の畳み込みなどが行われます。',
        '【リンカとローダ】\nリンカ：複数のオブジェクトファイルと必要なライブラリを結合し、実行可能ファイルを生成します。静的リンクと動的リンクがあります。\nローダ：実行可能ファイルをメモリに読み込み、実行の準備を行います。アドレスの再配置なども行います。',
        '【エラーの種類】\n・コンパイルエラー：文法的な誤りによって発生\n・リンクエラー：参照している関数や変数が見つからない場合に発生\n・実行時エラー：プログラム実行中に発生（ゼロ除算、配列の範囲外アクセスなど）'
      ],
      examples: [
        {
          title: 'C言語のコンパイルプロセス',
          code: `// main.c
#include <stdio.h>
#include "math_utils.h"

int main() {
    int result = add(5, 3);
    printf("5 + 3 = %d\\n", result);
    return 0;
}

// math_utils.c
int add(int a, int b) {
    return a + b;
}

// コンパイルコマンド
$ gcc -c main.c        # main.oを生成
$ gcc -c math_utils.c  # math_utils.oを生成
$ gcc main.o math_utils.o -o program  # リンクして実行ファイル生成
$ ./program            # 実行`,
          explanation: '複数のソースファイルから実行ファイルを生成する過程を示しています。各ファイルは個別にコンパイルされ、最後にリンクされます。'
        }
      ],
      keyPoints: [
        'コンパイラ方式は、ソースコード全体を機械語に変換してから実行する',
        'コンパイル過程には、字句解析、構文解析、意味解析、最適化の段階がある',
        'リンカは複数のオブジェクトファイルを結合して実行可能ファイルを作成する',
        'エラーには、コンパイルエラー、リンクエラー、実行時エラーがある'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: 'コンパイル過程で、ソースコードをトークンに分解する処理は何と呼ばれるか。',
        options: [
          '構文解析',
          '字句解析',
          '意味解析',
          '最適化'
        ],
        correctAnswer: 1,
        explanation: '字句解析（レキシカル解析）は、ソースコードを最小単位であるトークンに分解する処理です。'
      },
      {
        id: 'q2',
        question: 'リンカの役割として適切なものはどれか。',
        options: [
          'ソースコードを機械語に変換する',
          '実行ファイルをメモリに読み込む',
          '複数のオブジェクトファイルを結合する',
          'プログラムの文法をチェックする'
        ],
        correctAnswer: 2,
        explanation: 'リンカは、複数のオブジェクトファイルとライブラリを結合して、実行可能ファイルを生成する役割を持ちます。'
      }
    ]
  },
  'variables': {
    id: 'variables',
    title: '変数は入れ物として使う箱',
    content: {
      overview: '変数は、プログラム中でデータを一時的に保存するための「箱」のようなものです。この箱には名前（変数名）がついており、中身（値）を入れたり取り出したりすることができます。',
      details: [
        '【変数の基本概念】\n変数は、メモリ上の特定の領域に付けられた名前です。プログラマは変数名を使ってその領域にアクセスし、データの読み書きを行います。変数を使うことで、同じ値を何度も使い回したり、計算結果を保存したりすることができます。',
        '【変数の宣言と初期化】\n宣言：変数を使用することをコンピュータに伝える処理。変数名と型を指定します。\n初期化：変数に最初の値を設定する処理。宣言と同時に行うことも、後から行うこともできます。\n\n多くの言語では、使用前に変数を宣言する必要があります。',
        '【データ型】\n整数型（int）：整数を扱う（例：-5, 0, 100）\n浮動小数点型（float, double）：小数を扱う（例：3.14, -0.5）\n文字型（char）：1文字を扱う（例：\'A\', \'あ\'）\n文字列型（string）：文字の並びを扱う（例："Hello"）\n論理型（boolean）：真偽値を扱う（true/false）\n\n静的型付け言語では変数の型を明示的に指定し、動的型付け言語では値によって自動的に型が決まります。',
        '【変数のスコープ】\nグローバル変数：プログラム全体から参照可能な変数\nローカル変数：特定の関数やブロック内でのみ有効な変数\n\nスコープを適切に管理することで、変数の衝突を防ぎ、メモリを効率的に使用できます。',
        '【変数の命名規則】\n・意味のある名前を付ける（例：age, userName, totalPrice）\n・予約語は使用できない\n・多くの言語では、英数字とアンダースコアが使用可能\n・大文字と小文字は区別される（多くの言語で）\n・数字から始まる変数名は使用できない'
      ],
      examples: [
        {
          title: '様々な言語での変数の使用例',
          code: `// C言語
int age = 20;           // 整数型の変数
double height = 170.5;  // 浮動小数点型の変数
char grade = 'A';       // 文字型の変数

// Python
age = 20              # 型を指定しない（動的型付け）
height = 170.5
grade = 'A'
name = "田中太郎"     # 文字列

// Java
int age = 20;
double height = 170.5;
char grade = 'A';
String name = "田中太郎";
boolean isStudent = true;  // 論理型`,
          explanation: '各言語で変数の宣言方法は異なりますが、「データを保存する箱」という概念は共通です。'
        },
        {
          title: '変数を使った計算の例',
          code: `// 変数を使わない場合
total = 100 * 1.1 + 200 * 1.1 + 300 * 1.1;

// 変数を使った場合
taxRate = 1.1;
price1 = 100;
price2 = 200;
price3 = 300;
total = price1 * taxRate + price2 * taxRate + price3 * taxRate;

// または
subtotal = price1 + price2 + price3;
total = subtotal * taxRate;`,
          explanation: '変数を使うことで、値の意味が明確になり、変更も容易になります。税率が変わっても、taxRateの値を変更するだけで済みます。'
        }
      ],
      keyPoints: [
        '変数はデータを保存する「箱」のようなもの',
        '変数には名前（変数名）と型（データ型）がある',
        '変数のスコープによって、参照できる範囲が決まる',
        '意味のある変数名を付けることで、プログラムの可読性が向上する'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: '変数の説明として適切でないものはどれか。',
        options: [
          'データを一時的に保存するための領域である',
          '一度設定した値は変更できない',
          'プログラム中で値を再利用できる',
          'メモリ上の特定の領域に付けられた名前である'
        ],
        correctAnswer: 1,
        explanation: '変数の値は、プログラムの実行中に変更することができます。一度設定した値を変更できないのは「定数」の特徴です。'
      },
      {
        id: 'q2',
        question: 'ローカル変数の特徴として適切なものはどれか。',
        options: [
          'プログラム全体から参照できる',
          '特定の関数やブロック内でのみ有効',
          'プログラムの実行が終了してもメモリに残る',
          '複数の関数で同じ名前を使用できない'
        ],
        correctAnswer: 1,
        explanation: 'ローカル変数は、宣言された関数やブロック内でのみ有効です。異なる関数であれば、同じ名前のローカル変数を使用できます。'
      }
    ]
  },
  'structured-programming': {
    id: 'structured-programming',
    title: '構造化プログラミング',
    content: {
      overview: '構造化プログラミングは、プログラムを「順次」「選択」「反復」の3つの基本構造の組み合わせで表現する手法です。これにより、プログラムの流れが明確になり、理解しやすく保守しやすいコードを書くことができます。',
      details: [
        '【順次構造（Sequence）】\n処理を上から下へ順番に実行する最も基本的な構造です。プログラムは記述された順序通りに実行されます。\n\n例：\n1. 変数に値を代入\n2. 計算を実行\n3. 結果を表示\n\nこのような一連の処理が順次構造です。',
        '【選択構造（Selection）】\n条件によって実行する処理を選択する構造です。主にif文やswitch文で実現されます。\n\n・if文：条件が真の場合に処理を実行\n・if-else文：条件が真の場合と偽の場合で異なる処理を実行\n・else-if文：複数の条件を順番に評価\n・switch文：値に応じて複数の処理から選択',
        '【反復構造（Iteration）】\n同じ処理を繰り返し実行する構造です。ループ文とも呼ばれます。\n\n・for文：回数が決まっている繰り返し\n・while文：条件が真の間、繰り返し\n・do-while文：最低1回は実行し、条件が真の間繰り返し\n\n無限ループを避けるため、必ず終了条件を設定することが重要です。',
        '【構造化定理】\nどんな複雑なアルゴリズムも、この3つの基本構造の組み合わせで表現できることが数学的に証明されています（構造化定理）。\n\nGOTO文を使わずにプログラムを記述することで、プログラムの流れが明確になります。',
        '【構造化プログラミングの利点】\n・可読性の向上：プログラムの流れが理解しやすい\n・保守性の向上：修正や機能追加が容易\n・デバッグの効率化：エラーの原因を特定しやすい\n・再利用性：部品化しやすく、他のプログラムでも使える\n・チーム開発：複数人での開発が効率的に行える'
      ],
      examples: [
        {
          title: '3つの基本構造の例',
          code: `// 順次構造
int a = 10;
int b = 20;
int sum = a + b;
printf("合計: %d", sum);

// 選択構造
if (score >= 80) {
    grade = 'A';
} else if (score >= 60) {
    grade = 'B';
} else {
    grade = 'C';
}

// 反復構造
for (int i = 1; i <= 10; i++) {
    sum += i;
}`,
          explanation: '順次構造で値を計算し、選択構造で条件分岐を行い、反復構造で繰り返し処理を実行しています。'
        },
        {
          title: '構造化プログラミングで書いた例',
          code: `// 1から100までの偶数の合計を求める
int sum = 0;
for (int i = 1; i <= 100; i++) {
    if (i % 2 == 0) {
        sum += i;
    }
}
printf("偶数の合計: %d", sum);

// 同じ処理を関数化
int sumEvenNumbers(int max) {
    int sum = 0;
    for (int i = 1; i <= max; i++) {
        if (i % 2 == 0) {
            sum += i;
        }
    }
    return sum;
}

// 使用例
int result = sumEvenNumbers(100);
printf("偶数の合計: %d", result);`,
          explanation: '反復構造の中に選択構造を組み込んでいます。また、処理を関数として独立させることで再利用性を高めています。'
        }
      ],
      keyPoints: [
        '構造化プログラミングは「順次」「選択」「反復」の3つの基本構造で構成される',
        '順次構造は上から下へ順番に処理を実行する',
        '選択構造は条件によって処理を分岐させる',
        '反復構造は同じ処理を繰り返し実行する',
        'GOTO文を使わずに、読みやすく保守しやすいプログラムを作成できる'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: '構造化プログラミングの基本構造に含まれないものはどれか。',
        options: [
          '順次構造',
          '選択構造',
          '反復構造',
          '並列構造'
        ],
        correctAnswer: 3,
        explanation: '構造化プログラミングの基本構造は「順次」「選択」「反復」の3つです。並列構造は含まれません。'
      },
      {
        id: 'q2',
        question: 'while文とdo-while文の違いとして適切なものはどれか。',
        options: [
          'while文は条件を後で評価する',
          'do-while文は最低1回は処理を実行する',
          'while文は回数が決まっている場合に使う',
          'do-while文は無限ループになりやすい'
        ],
        correctAnswer: 1,
        explanation: 'do-while文は、条件の評価前に必ず1回は処理を実行します。while文は最初に条件を評価するため、条件が偽の場合は一度も実行されません。'
      }
    ]
  },
  'algorithm-flowchart': {
    id: 'algorithm-flowchart',
    title: 'アルゴリズムとフローチャート',
    content: {
      overview: 'アルゴリズムは問題を解決するための手順や方法を表したものです。フローチャートは、このアルゴリズムを図式化して視覚的に表現する方法で、プログラムの流れを理解しやすくします。',
      details: [
        '【アルゴリズムとは】\nアルゴリズムは、ある問題を解決するための有限の手順です。料理のレシピのように、決められた順序で処理を行うことで、目的の結果を得ることができます。\n\n良いアルゴリズムの条件：\n・正確性：正しい結果を出力する\n・効率性：処理時間やメモリ使用量が少ない\n・汎用性：様々な入力に対応できる\n・可読性：理解しやすい',
        '【フローチャートの基本記号】\n・端子記号（楕円）：開始と終了を表す\n・処理記号（長方形）：計算や代入などの処理を表す\n・判断記号（ひし形）：条件分岐を表す\n・入出力記号（平行四辺形）：データの入力や出力を表す\n・流れ線（矢印）：処理の流れを表す\n・結合子（円）：フローチャートの接続点を表す',
        '【フローチャートの作成手順】\n1. 問題を理解し、入力と出力を明確にする\n2. 処理の大まかな流れを考える\n3. 詳細な処理手順を決める\n4. フローチャートの記号を使って図式化する\n5. 処理の流れを確認し、必要に応じて修正する',
        '【アルゴリズムの表現方法】\n・自然言語：日常的な言葉で記述\n・フローチャート：図式で視覚的に表現\n・擬似コード：プログラミング言語に似た形式で記述\n・プログラミング言語：実際に実行可能な形式で記述\n\n各表現方法には長所と短所があり、目的に応じて使い分けます。',
        '【基本的なアルゴリズムパターン】\n・逐次処理：順番に処理を実行\n・条件分岐：条件によって処理を選択\n・繰り返し：同じ処理を反復実行\n・再帰：自分自身を呼び出す処理\n\nこれらのパターンを組み合わせることで、複雑な問題も解決できます。'
      ],
      examples: [
        {
          title: '最大値を求めるアルゴリズム',
          code: `【自然言語での表現】
1. 配列の最初の要素を最大値とする
2. 2番目以降の要素を順番に調べる
3. 現在の最大値より大きい要素があれば、それを新しい最大値とする
4. すべての要素を調べ終わったら、最大値を出力する

【擬似コード】
max = array[0]
for i = 1 to array.length - 1
    if array[i] > max then
        max = array[i]
    end if
end for
output max

【実際のコード（Python）】
def find_max(array):
    max_value = array[0]
    for i in range(1, len(array)):
        if array[i] > max_value:
            max_value = array[i]
    return max_value`,
          explanation: '同じアルゴリズムを異なる方法で表現しています。目的や対象者に応じて適切な表現方法を選びます。'
        }
      ],
      keyPoints: [
        'アルゴリズムは問題解決のための有限の手順',
        'フローチャートはアルゴリズムを図式化したもの',
        'フローチャートには決められた記号があり、それぞれ意味がある',
        '良いアルゴリズムは正確で効率的である',
        'アルゴリズムは様々な方法で表現できる'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: 'フローチャートで条件分岐を表す記号はどれか。',
        options: [
          '長方形',
          'ひし形',
          '楕円',
          '平行四辺形'
        ],
        correctAnswer: 1,
        explanation: 'ひし形は判断記号と呼ばれ、条件分岐を表します。長方形は処理、楕円は端子、平行四辺形は入出力を表します。'
      },
      {
        id: 'q2',
        question: '良いアルゴリズムの条件として適切でないものはどれか。',
        options: [
          '正確な結果を出力する',
          '処理時間が短い',
          '複雑で理解しにくい',
          '様々な入力に対応できる'
        ],
        correctAnswer: 2,
        explanation: '良いアルゴリズムは理解しやすい（可読性が高い）ことが重要です。複雑で理解しにくいアルゴリズムは保守や修正が困難になります。'
      }
    ]
  },
  'data-structure': {
    id: 'data-structure',
    title: 'データの持ち方',
    content: {
      overview: 'データ構造は、データを効率的に管理・操作するための仕組みです。適切なデータ構造を選択することで、プログラムの性能を大幅に向上させることができます。',
      details: [
        '【配列（Array）】\n同じ型のデータを連続したメモリ領域に格納する構造です。\n\n特徴：\n・インデックス（添字）による高速なアクセス（O(1)）\n・要素数が固定（静的配列の場合）\n・メモリ上に連続して配置される\n・挿入や削除が遅い（O(n)）\n\n用途：大量のデータを順番に処理する場合、ランダムアクセスが必要な場合',
        '【リスト（List）】\n要素を順序付けて管理する構造です。\n\n連結リスト（Linked List）：\n・各要素が次の要素へのポインタを持つ\n・挿入・削除が高速（O(1)）\n・ランダムアクセスが遅い（O(n)）\n・メモリを動的に確保\n\n双方向リスト：前後両方向へのポインタを持つ\n循環リスト：最後の要素が最初の要素を指す',
        '【スタック（Stack）】\nLIFO（Last In First Out：後入れ先出し）の原則で動作するデータ構造です。\n\n基本操作：\n・push：要素を頂上に追加\n・pop：頂上の要素を取り出す\n・peek/top：頂上の要素を参照（取り出さない）\n・isEmpty：スタックが空か確認\n\n用途：関数呼び出しの管理、式の評価、undo機能の実装',
        '【キュー（Queue）】\nFIFO（First In First Out：先入れ先出し）の原則で動作するデータ構造です。\n\n基本操作：\n・enqueue：要素を末尾に追加\n・dequeue：先頭の要素を取り出す\n・front：先頭の要素を参照\n・isEmpty：キューが空か確認\n\n用途：タスクの順次処理、幅優先探索、プリンタのジョブ管理',
        '【ハッシュテーブル（Hash Table）】\nキーと値のペアを効率的に管理するデータ構造です。\n\n特徴：\n・ハッシュ関数でキーを配列のインデックスに変換\n・平均的にO(1)での検索・挿入・削除\n・ハッシュ衝突の処理が必要（チェイン法、オープンアドレス法）\n\n用途：辞書、データベースのインデックス、キャッシュ'
      ],
      examples: [
        {
          title: '各データ構造の実装例',
          code: `// 配列
int array[5] = {10, 20, 30, 40, 50};
int value = array[2];  // インデックス2の要素（30）を取得

// スタックの操作
Stack stack;
stack.push(10);
stack.push(20);
stack.push(30);
int top = stack.pop();  // 30が取り出される（LIFO）

// キューの操作
Queue queue;
queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
int front = queue.dequeue();  // 10が取り出される（FIFO）

// 連結リストのノード
struct Node {
    int data;
    Node* next;
};`,
          explanation: '各データ構造には特有の操作方法があり、用途に応じて使い分けます。'
        },
        {
          title: 'スタックを使った括弧の対応チェック',
          code: `bool checkBrackets(string str) {
    Stack<char> stack;
    
    for (char c : str) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else if (c == ')' || c == '}' || c == ']') {
            if (stack.isEmpty()) return false;
            
            char top = stack.pop();
            if ((c == ')' && top != '(') ||
                (c == '}' && top != '{') ||
                (c == ']' && top != '[')) {
                return false;
            }
        }
    }
    
    return stack.isEmpty();
}`,
          explanation: 'スタックは括弧の対応チェックに適しています。開き括弧をpushし、閉じ括弧でpopして対応を確認します。'
        }
      ],
      keyPoints: [
        '配列は高速なランダムアクセスが可能だが、サイズが固定',
        'リストは動的にサイズを変更でき、挿入・削除が効率的',
        'スタックはLIFO、キューはFIFOの原則で動作',
        'ハッシュテーブルは高速な検索が可能',
        '問題に応じて適切なデータ構造を選択することが重要'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: 'LIFO（後入れ先出し）の原則で動作するデータ構造はどれか。',
        options: [
          '配列',
          'キュー',
          'スタック',
          'ハッシュテーブル'
        ],
        correctAnswer: 2,
        explanation: 'スタックはLIFO（Last In First Out）の原則で動作します。最後に入れた要素が最初に取り出されます。'
      },
      {
        id: 'q2',
        question: '配列の特徴として適切でないものはどれか。',
        options: [
          'インデックスによる高速アクセスが可能',
          '要素の挿入・削除が高速',
          'メモリ上に連続して配置される',
          '同じ型のデータを格納する'
        ],
        correctAnswer: 1,
        explanation: '配列の要素の挿入・削除は、他の要素をシフトする必要があるため遅い（O(n)）です。高速な挿入・削除が必要な場合はリストを使用します。'
      }
    ]
  },
  'tree-structure': {
    id: 'tree-structure',
    title: '木構造',
    content: {
      overview: '木構造は、階層的な関係を持つデータを表現するのに適したデータ構造です。ファイルシステム、組織図、決定木など、様々な場面で使用されます。',
      details: [
        '【木構造の基本用語】\n・ノード（節点）：データを格納する要素\n・ルート（根）：木の最上位のノード\n・リーフ（葉）：子を持たないノード\n・エッジ（辺）：ノード間の接続\n・親ノード：あるノードの直接の上位ノード\n・子ノード：あるノードの直接の下位ノード\n・深さ：ルートからの距離\n・高さ：最も深いリーフまでの距離',
        '【二分木（Binary Tree）】\n各ノードが最大2つの子を持つ木構造です。\n\n種類：\n・完全二分木：最下段以外のレベルが満杯で、最下段は左詰め\n・満二分木：すべての内部ノードが2つの子を持つ\n・平衡二分木：左右の部分木の高さの差が1以下\n\n用途：式の構文木、決定木、ヒープ',
        '【二分探索木（Binary Search Tree）】\n効率的な検索を可能にする二分木です。\n\n性質：\n・左の子 < 親 < 右の子の関係を満たす\n・中間順走査で昇順にデータを取得できる\n\n操作の時間計算量：\n・検索：平均O(log n)、最悪O(n)\n・挿入：平均O(log n)、最悪O(n)\n・削除：平均O(log n)、最悪O(n)',
        '【木の走査（Traversal）】\n木構造のすべてのノードを系統的に訪問する方法です。\n\n深さ優先探索（DFS）：\n・前順走査（Preorder）：親→左→右\n・中間順走査（Inorder）：左→親→右\n・後順走査（Postorder）：左→右→親\n\n幅優先探索（BFS）：\n・レベル順走査：同じ深さのノードを左から右へ順に訪問',
        '【平衡木】\n木の高さを自動的に調整し、操作の効率を保つ木構造です。\n\nAVL木：\n・各ノードの左右の部分木の高さの差が1以下\n・回転操作により平衡を保つ\n\n赤黒木：\n・ノードに色（赤または黒）を付けて平衡を管理\n・挿入・削除がAVL木より高速\n\nB木：\n・複数の子を持つことができる平衡木\n・データベースやファイルシステムで使用'
      ],
      examples: [
        {
          title: '二分探索木の実装',
          code: `struct Node {
    int data;
    Node* left;
    Node* right;
};

// 挿入
Node* insert(Node* root, int value) {
    if (root == NULL) {
        Node* newNode = new Node();
        newNode->data = value;
        newNode->left = NULL;
        newNode->right = NULL;
        return newNode;
    }
    
    if (value < root->data) {
        root->left = insert(root->left, value);
    } else if (value > root->data) {
        root->right = insert(root->right, value);
    }
    
    return root;
}

// 検索
bool search(Node* root, int value) {
    if (root == NULL) return false;
    if (root->data == value) return true;
    
    if (value < root->data) {
        return search(root->left, value);
    } else {
        return search(root->right, value);
    }
}`,
          explanation: '二分探索木では、値の大小関係を利用して効率的に検索・挿入を行います。'
        },
        {
          title: '木の走査方法',
          code: `// 前順走査（Preorder）
void preorder(Node* root) {
    if (root != NULL) {
        print(root->data);    // 親
        preorder(root->left);  // 左
        preorder(root->right); // 右
    }
}

// 中間順走査（Inorder）
void inorder(Node* root) {
    if (root != NULL) {
        inorder(root->left);   // 左
        print(root->data);     // 親
        inorder(root->right);  // 右
    }
}

// 後順走査（Postorder）
void postorder(Node* root) {
    if (root != NULL) {
        postorder(root->left);  // 左
        postorder(root->right); // 右
        print(root->data);      // 親
    }
}`,
          explanation: '走査方法によって、ノードを訪問する順序が異なります。二分探索木の中間順走査では、データが昇順に取得されます。'
        }
      ],
      keyPoints: [
        '木構造は階層的なデータを表現するのに適している',
        '二分木は各ノードが最大2つの子を持つ',
        '二分探索木は効率的な検索を可能にする',
        '木の走査には深さ優先探索と幅優先探索がある',
        '平衡木は自動的に高さを調整し、性能を保つ'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: '二分探索木の中間順走査で得られる結果の特徴はどれか。',
        options: [
          'ランダムな順序で出力される',
          '昇順に出力される',
          '降順に出力される',
          '挿入順に出力される'
        ],
        correctAnswer: 1,
        explanation: '二分探索木を中間順走査すると、左の子→親→右の子の順で訪問するため、データが昇順に出力されます。'
      },
      {
        id: 'q2',
        question: '平衡木の目的として適切なものはどれか。',
        options: [
          'メモリ使用量を最小にする',
          '木の高さを最小に保つ',
          'ノード数を最小にする',
          'エッジ数を最大にする'
        ],
        correctAnswer: 1,
        explanation: '平衡木は木の高さを最小に保つことで、検索・挿入・削除の操作をO(log n)で実行できるようにします。'
      }
    ]
  },
  'search-algorithm': {
    id: 'search-algorithm',
    title: 'データを探索するアルゴリズム',
    content: {
      overview: '探索アルゴリズムは、大量のデータの中から特定の値を見つけ出すための手法です。データの並び方や量に応じて、適切なアルゴリズムを選択することが重要です。',
      details: [
        '【線形探索（Linear Search）】\n配列の先頭から順番に目的の値を探す最も単純な探索方法です。\n\n特徴：\n・時間計算量：O(n)\n・ソートされていないデータでも使用可能\n・実装が簡単\n・小規模なデータには効率的\n\n適用場面：\n・データ数が少ない場合\n・一度だけ探索する場合\n・データがソートされていない場合',
        '【二分探索（Binary Search）】\nソート済みのデータに対して、中央の値と比較しながら探索範囲を半分ずつ絞り込んでいく方法です。\n\n特徴：\n・時間計算量：O(log n)\n・事前にデータのソートが必要\n・大規模なデータに効果的\n・探索回数が少ない\n\n動作原理：\n1. 中央の要素と目的の値を比較\n2. 一致すれば探索終了\n3. 目的の値が小さければ左半分を探索\n4. 目的の値が大きければ右半分を探索',
        '【ハッシュ探索（Hash Search）】\nハッシュ関数を使用してデータの格納位置を計算し、直接アクセスする方法です。\n\n特徴：\n・平均時間計算量：O(1)\n・最悪時間計算量：O(n)（衝突が多い場合）\n・追加のメモリ空間が必要\n・ハッシュ関数の設計が重要\n\nハッシュ衝突の解決法：\n・チェイン法：同じハッシュ値のデータをリストで管理\n・オープンアドレス法：別の空き位置を探す',
        '【幅優先探索（BFS: Breadth-First Search）】\nグラフや木構造で、始点から近い順に探索する方法です。\n\n特徴：\n・最短経路を見つけることができる\n・キューを使用して実装\n・メモリ使用量が多い\n\n用途：\n・最短経路問題\n・迷路の解法\n・ソーシャルネットワークの分析',
        '【深さ優先探索（DFS: Depth-First Search）】\nグラフや木構造で、できるだけ深く進んでから戻る探索方法です。\n\n特徴：\n・スタックまたは再帰で実装\n・メモリ使用量が少ない\n・すべての経路を探索できる\n\n用途：\n・経路の全探索\n・トポロジカルソート\n・連結成分の検出'
      ],
      examples: [
        {
          title: '線形探索と二分探索の実装',
          code: `// 線形探索
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;  // 見つかったインデックスを返す
        }
    }
    return -1;  // 見つからない場合
}

// 二分探索（配列はソート済み）
int binarySearch(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;  // 見つかった
        } else if (arr[mid] < target) {
            left = mid + 1;  // 右半分を探索
        } else {
            right = mid - 1;  // 左半分を探索
        }
    }
    return -1;  // 見つからない場合
}`,
          explanation: '二分探索は探索範囲を半分ずつ絞り込むため、大規模データでは線形探索より圧倒的に高速です。'
        },
        {
          title: '探索回数の比較',
          code: `// 1000個の要素から探索する場合の最大探索回数

// 線形探索
最大探索回数 = 1000回

// 二分探索
最大探索回数 = log₂(1000) ≈ 10回

// 100万個の要素の場合
線形探索：最大100万回
二分探索：最大20回（log₂(1000000) ≈ 20）`,
          explanation: 'データ量が増えるほど、二分探索の優位性が顕著になります。'
        }
      ],
      keyPoints: [
        '線形探索は単純だが時間がかかる（O(n)）',
        '二分探索は高速だがソート済みデータが必要（O(log n)）',
        'ハッシュ探索は平均的に最も高速（O(1)）',
        'グラフの探索にはBFSとDFSがある',
        'データの特性に応じて適切な探索アルゴリズムを選択する'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: '二分探索を使用するための前提条件はどれか。',
        options: [
          'データが重複していないこと',
          'データがソートされていること',
          'データ数が偶数であること',
          'データがすべて正の値であること'
        ],
        correctAnswer: 1,
        explanation: '二分探索は、データがソートされていることが前提条件です。ソートされていないデータには使用できません。'
      },
      {
        id: 'q2',
        question: '1024個の要素を持つソート済み配列に対して二分探索を行う場合、最大何回の比較で探索が完了するか。',
        options: [
          '10回',
          '11回',
          '512回',
          '1024回'
        ],
        correctAnswer: 1,
        explanation: '二分探索の最大比較回数は、log₂(n) + 1です。log₂(1024) = 10なので、最大11回の比較で探索が完了します。'
      }
    ]
  },
  'sort-algorithm': {
    id: 'sort-algorithm',
    title: 'データを整列させるアルゴリズム',
    content: {
      overview: 'ソートアルゴリズムは、データを特定の順序（昇順・降順）に並び替える手法です。データ量や特性に応じて、適切なアルゴリズムを選択することで効率的な処理が可能になります。',
      details: [
        '【バブルソート（Bubble Sort）】\n隣接する要素を比較して交換を繰り返す単純なソート方法です。\n\n特徴：\n・時間計算量：O(n²)\n・安定ソート（同じ値の順序が保持される）\n・実装が簡単\n・小規模データや既にほぼソート済みのデータに適する\n\n動作：泡が浮き上がるように、大きい値が徐々に後ろに移動していきます。',
        '【選択ソート（Selection Sort）】\n未ソート部分から最小値（最大値）を選択して先頭と交換する方法です。\n\n特徴：\n・時間計算量：O(n²)\n・不安定ソート\n・交換回数が少ない\n・メモリ使用量が少ない\n\n動作：各ステップで最小値を見つけて、正しい位置に配置していきます。',
        '【挿入ソート（Insertion Sort）】\nソート済み部分に、未ソート部分の要素を適切な位置に挿入していく方法です。\n\n特徴：\n・時間計算量：平均O(n²)、最良O(n)\n・安定ソート\n・ほぼソート済みのデータに効率的\n・オンラインアルゴリズム（データを逐次処理可能）\n\n動作：トランプを手札に並べるように、適切な位置に挿入していきます。',
        '【クイックソート（Quick Sort）】\n基準値（ピボット）を選び、それより小さい要素と大きい要素に分割して再帰的にソートする方法です。\n\n特徴：\n・平均時間計算量：O(n log n)\n・最悪時間計算量：O(n²)\n・不安定ソート\n・実用上最も高速な場合が多い\n・分割統治法の代表例\n\nピボットの選び方：\n・先頭または末尾の要素\n・中央の要素\n・ランダムに選択\n・3つの要素の中央値',
        '【マージソート（Merge Sort）】\n配列を半分に分割し、それぞれをソートしてから統合する方法です。\n\n特徴：\n・時間計算量：O(n log n)（最悪でも）\n・安定ソート\n・追加メモリが必要：O(n)\n・大規模データに適する\n・分割統治法の代表例\n\n動作：分割→ソート→統合を再帰的に繰り返します。',
        '【ヒープソート（Heap Sort）】\nヒープ構造を利用してソートする方法です。\n\n特徴：\n・時間計算量：O(n log n)\n・不安定ソート\n・追加メモリ不要（in-place）\n・最悪でもO(n log n)を保証\n\n動作：\n1. 配列をヒープ構造に変換\n2. 最大値（ルート）を取り出して配列の末尾に配置\n3. ヒープを再構築して繰り返す'
      ],
      examples: [
        {
          title: '主要なソートアルゴリズムの実装',
          code: `// バブルソート
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
            }
        }
    }
}

// クイックソート
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pivot = partition(arr, low, high);
        quickSort(arr, low, pivot - 1);
        quickSort(arr, pivot + 1, high);
    }
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}`,
          explanation: 'バブルソートは単純ですが効率が悪く、クイックソートは高速ですが実装が複雑です。'
        },
        {
          title: 'ソートアルゴリズムの比較',
          code: `アルゴリズム    | 平均計算量  | 最悪計算量  | 安定性 | メモリ
-------------|-----------|-----------|-------|-------
バブルソート    | O(n²)     | O(n²)     | 安定   | O(1)
選択ソート     | O(n²)     | O(n²)     | 不安定 | O(1)
挿入ソート     | O(n²)     | O(n²)     | 安定   | O(1)
クイックソート  | O(n log n) | O(n²)     | 不安定 | O(log n)
マージソート   | O(n log n) | O(n log n) | 安定   | O(n)
ヒープソート   | O(n log n) | O(n log n) | 不安定 | O(1)`,
          explanation: '各アルゴリズムには長所と短所があり、用途に応じて選択します。'
        }
      ],
      keyPoints: [
        'O(n²)のアルゴリズム（バブル、選択、挿入）は実装が簡単だが遅い',
        'O(n log n)のアルゴリズム（クイック、マージ、ヒープ）は高速',
        '安定ソートは同じ値の順序を保持する',
        'クイックソートは平均的に最速だが、最悪ケースに注意',
        'データの特性（サイズ、初期状態）に応じて適切なアルゴリズムを選択'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: '安定ソートの特徴として適切なものはどれか。',
        options: [
          '実行時間が一定である',
          '追加メモリを使用しない',
          '同じ値の要素の順序が保持される',
          '最悪計算量がO(n log n)である'
        ],
        correctAnswer: 2,
        explanation: '安定ソートは、同じ値を持つ要素の相対的な順序が、ソート前後で保持される特徴があります。'
      },
      {
        id: 'q2',
        question: 'クイックソートの最悪計算量がO(n²)になる場合はどれか。',
        options: [
          'データがランダムな場合',
          'データが既にソート済みの場合',
          'データが逆順の場合',
          'すべての要素が同じ値の場合'
        ],
        correctAnswer: 1,
        explanation: 'データが既にソート済みで、ピボットを先頭または末尾から選ぶ場合、分割が偏ってO(n²)になります。'
      }
    ]
  },
  'order-notation': {
    id: 'order-notation',
    title: 'オーダ記法',
    content: {
      overview: 'オーダ記法（Big O記法）は、アルゴリズムの効率性を表す記法です。入力データ量nに対して、実行時間やメモリ使用量がどのように増加するかを示します。',
      details: [
        '【オーダ記法とは】\nアルゴリズムの計算量を、入力サイズnの関数として表現する記法です。\n\n特徴：\n・最も影響の大きい項のみを残す\n・定数倍は無視する\n・最悪ケースを表すことが多い\n\n例：3n² + 5n + 10 → O(n²)\n最高次の項n²のみを残し、係数3は無視します。',
        '【主なオーダと特徴】\nO(1) - 定数時間：\n・入力サイズに関係なく一定時間\n・例：配列の要素アクセス、ハッシュテーブルの検索\n\nO(log n) - 対数時間：\n・データが倍になっても実行時間は1増えるだけ\n・例：二分探索、平衡木の操作\n\nO(n) - 線形時間：\n・データ量に比例して実行時間が増加\n・例：線形探索、配列の走査',
        '【よく使われるオーダ】\nO(n log n)：\n・効率的なソートアルゴリズム\n・例：マージソート、ヒープソート\n\nO(n²) - 二乗時間：\n・二重ループの処理\n・例：バブルソート、選択ソート\n\nO(n³) - 三乗時間：\n・三重ループの処理\n・例：行列の乗算（単純な実装）\n\nO(2ⁿ) - 指数時間：\n・すべての部分集合を調べる\n・例：巡回セールスマン問題（総当たり）',
        '【計算量の求め方】\n1. 基本演算の回数を数える\n2. ループの回数を分析\n3. 再帰の深さと各レベルの処理を考慮\n4. 最も影響の大きい項を抽出\n\n例：二重ループ\nfor i = 1 to n:\n    for j = 1 to n:\n        処理  // n × n = n²回実行\n→ O(n²)',
        '【空間計算量】\n時間計算量だけでなく、メモリ使用量も重要です。\n\nO(1) - 定数空間：\n・追加メモリがほぼ不要\n・例：バブルソート（in-place）\n\nO(n) - 線形空間：\n・入力サイズに比例したメモリ\n・例：マージソート（作業用配列）\n\nO(log n) - 対数空間：\n・再帰呼び出しのスタック\n・例：クイックソート（再帰の深さ）',
        '【実用的な目安】\nn = 10：ほぼすべてのアルゴリズムが瞬時\nn = 100：O(n³)まで実用的\nn = 1,000：O(n²)まで実用的\nn = 10,000：O(n log n)まで実用的\nn = 100,000：O(n)が望ましい\nn = 1,000,000：O(n)またはO(log n)が必要'
      ],
      examples: [
        {
          title: 'オーダの計算例',
          code: `// O(1) - 定数時間
int getElement(int arr[], int index) {
    return arr[index];  // 1回のアクセス
}

// O(n) - 線形時間
int sum(int arr[], int n) {
    int total = 0;
    for (int i = 0; i < n; i++) {  // n回のループ
        total += arr[i];
    }
    return total;
}

// O(n²) - 二乗時間
void printPairs(int arr[], int n) {
    for (int i = 0; i < n; i++) {      // n回
        for (int j = 0; j < n; j++) {  // 各iに対してn回
            printf("(%d, %d)", arr[i], arr[j]);
        }
    }
}

// O(log n) - 対数時間
int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        // 毎回探索範囲が半分になる
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}`,
          explanation: '各関数の計算量は、ループの回数や再帰の深さから導出できます。'
        },
        {
          title: 'オーダによる実行時間の違い',
          code: `n = 1,000,000（100万）の場合の演算回数（概算）

O(1)        : 1回
O(log n)    : 20回
O(n)        : 1,000,000回
O(n log n)  : 20,000,000回
O(n²)       : 1,000,000,000,000回（1兆回）

実行時間の目安（1秒間に10⁸回の演算が可能と仮定）
O(1)        : 0.00000001秒
O(log n)    : 0.0000002秒
O(n)        : 0.01秒
O(n log n)  : 0.2秒
O(n²)       : 10,000秒（約2.8時間）`,
          explanation: 'データ量が大きくなると、オーダの違いが実行時間に大きく影響します。'
        }
      ],
      keyPoints: [
        'オーダ記法はアルゴリズムの効率性を表す',
        '最高次の項のみを残し、定数倍は無視する',
        'O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)',
        '時間計算量と空間計算量の両方を考慮する',
        'データ量に応じて適切なオーダのアルゴリズムを選択する'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: '次の計算量をオーダ記法で表したとき、正しいものはどれか。「5n² + 3n + 100」',
        options: [
          'O(5n²)',
          'O(n²)',
          'O(n)',
          'O(100)'
        ],
        correctAnswer: 1,
        explanation: 'オーダ記法では最高次の項のみを残し、係数は無視します。したがって、5n² + 3n + 100 = O(n²)となります。'
      },
      {
        id: 'q2',
        question: 'n個のデータに対して、計算量がO(n log n)のアルゴリズムの例として適切なものはどれか。',
        options: [
          'バブルソート',
          '線形探索',
          'マージソート',
          '二分探索'
        ],
        correctAnswer: 2,
        explanation: 'マージソートの時間計算量はO(n log n)です。バブルソートはO(n²)、線形探索はO(n)、二分探索はO(log n)です。'
      }
    ]
  },
  'pseudo-code': {
    id: 'pseudo-code',
    title: '擬似言語問題を読み解こう',
    content: {
      overview: '擬似言語は、特定のプログラミング言語に依存しない形でアルゴリズムを表現する方法です。基本情報技術者試験では、擬似言語で書かれたプログラムを理解し、動作を追跡する能力が求められます。',
      details: [
        '【擬似言語の特徴】\n・自然言語とプログラミング言語の中間的な表現\n・特定の言語の文法に縛られない\n・アルゴリズムの本質を理解しやすい\n・基本情報技術者試験で使用される共通言語\n\n重要：試験では擬似言語の仕様書が提供されるので、それに従って読み解きます。',
        '【基本的な記法】\n変数の宣言と代入：\n・整数型：integer\n・実数型：real\n・文字型：char\n・論理型：boolean\n・配列：array\n\n演算子：\n・算術演算：+, -, *, /, mod（剰余）\n・比較演算：=, ≠, <, >, ≤, ≥\n・論理演算：and, or, not\n・代入：←',
        '【制御構造】\n条件分岐：\nif 条件 then\n    処理1\nelse\n    処理2\nendif\n\n繰り返し（for文）：\nfor 変数 ← 初期値 to 終了値 do\n    処理\nendfor\n\n繰り返し（while文）：\nwhile 条件 do\n    処理\nendwhile',
        '【配列とループ】\n配列の宣言：\narray A[10]  // 要素数10の配列\n\n配列の操作：\nA[0] ← 100  // 0番目に100を代入\nsum ← sum + A[i]  // i番目の要素を加算\n\n二次元配列：\narray B[5][3]  // 5行3列の配列\nB[i][j] ← value',
        '【関数・手続き】\n関数の定義：\nfunction 関数名(引数1, 引数2)\n    処理\n    return 戻り値\nendfunction\n\n関数の呼び出し：\nresult ← 関数名(実引数1, 実引数2)\n\n手続き（戻り値なし）：\nprocedure 手続き名(引数)\n    処理\nendprocedure',
        '【擬似言語問題の解き方】\n1. 変数の初期化を確認\n2. ループの回数と条件を把握\n3. 配列のインデックスに注意（0始まりか1始まりか）\n4. トレース表を作成して値の変化を追跡\n5. 境界値（最初と最後）の動作を確認\n\nコツ：\n・具体的な値で動作を追跡する\n・ループは最初の数回と最後を重点的に確認\n・配列の範囲外アクセスに注意'
      ],
      examples: [
        {
          title: '配列の最大値を求める擬似言語',
          code: `// 配列Aの最大値を求める
integer array A[5]
integer max, i

// 配列の初期化
A[0] ← 3
A[1] ← 7
A[2] ← 2
A[3] ← 9
A[4] ← 5

// 最大値の探索
max ← A[0]
for i ← 1 to 4 do
    if A[i] > max then
        max ← A[i]
    endif
endfor

output max  // 9が出力される

【トレース表】
i | A[i] | max | 比較結果
--|------|-----|----------
- |  -   |  3  | 初期値
1 |  7   |  7  | 7 > 3 → true
2 |  2   |  7  | 2 > 7 → false
3 |  9   |  9  | 9 > 7 → true
4 |  5   |  9  | 5 > 9 → false`,
          explanation: 'トレース表を使って各ステップでの変数の値を追跡することで、プログラムの動作を理解できます。'
        },
        {
          title: 'バブルソートの擬似言語',
          code: `// バブルソート
integer array A[5]
integer i, j, temp

// 配列の初期化
A[0] ← 5, A[1] ← 2, A[2] ← 8, A[3] ← 1, A[4] ← 3

// ソート処理
for i ← 0 to 3 do
    for j ← 0 to 3-i do
        if A[j] > A[j+1] then
            // 交換処理
            temp ← A[j]
            A[j] ← A[j+1]
            A[j+1] ← temp
        endif
    endfor
endfor

// 結果：A = [1, 2, 3, 5, 8]

【1回目の外側ループ（i=0）での配列の変化】
初期：[5, 2, 8, 1, 3]
j=0：[2, 5, 8, 1, 3]  // 5と2を交換
j=1：[2, 5, 8, 1, 3]  // 交換なし
j=2：[2, 5, 1, 8, 3]  // 8と1を交換
j=3：[2, 5, 1, 3, 8]  // 8と3を交換`,
          explanation: '二重ループの動作を理解するには、内側のループが完了するごとの状態を確認することが重要です。'
        }
      ],
      keyPoints: [
        '擬似言語は特定のプログラミング言語に依存しない',
        '基本的な制御構造（順次、選択、反復）を理解する',
        '配列のインデックスと範囲に注意する',
        'トレース表を使って変数の値の変化を追跡する',
        '具体的な値を使って動作を確認する'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: '次の擬似言語を実行した結果、変数sumの値はいくつになるか。\n\ninteger sum, i\nsum ← 0\nfor i ← 1 to 5 do\n    sum ← sum + i\nendfor',
        options: [
          '10',
          '15',
          '20',
          '25'
        ],
        correctAnswer: 1,
        explanation: '1から5までの合計を計算しています。sum = 1 + 2 + 3 + 4 + 5 = 15となります。'
      },
      {
        id: 'q2',
        question: '次の擬似言語で、配列A[0]からA[4]に格納された値の中で偶数の個数を数える処理として、空欄に入る適切なものはどれか。\n\ninteger count, i\ncount ← 0\nfor i ← 0 to 4 do\n    if [    ] then\n        count ← count + 1\n    endif\nendfor',
        options: [
          'A[i] = 2',
          'A[i] mod 2 = 0',
          'A[i] / 2 = 0',
          'A[i] mod 2 = 1'
        ],
        correctAnswer: 1,
        explanation: '偶数は2で割り切れる数なので、A[i] mod 2 = 0（剰余が0）が条件となります。'
      }
    ]
  },
  'oop': {
    id: 'oop',
    title: 'オブジェクト指向プログラミング',
    content: {
      overview: 'オブジェクト指向プログラミング（OOP）は、現実世界の「もの」をオブジェクトとしてモデル化し、それらの相互作用でプログラムを構築する手法です。大規模なソフトウェア開発において、保守性と再利用性を向上させます。',
      details: [
        '【オブジェクト指向の基本概念】\nオブジェクト：\n・データ（属性）と処理（メソッド）をまとめたもの\n・現実世界の「もの」をプログラムで表現\n・例：「車」オブジェクトは、色や速度（属性）と、走る・止まる（メソッド）を持つ\n\nクラス：\n・オブジェクトの設計図・型\n・同じ特性を持つオブジェクトの共通部分を定義\n・インスタンス：クラスから作成された個々のオブジェクト',
        '【カプセル化（Encapsulation）】\nデータと処理を一つにまとめ、外部からの直接アクセスを制限する仕組みです。\n\nアクセス修飾子：\n・public：どこからでもアクセス可能\n・private：同じクラス内からのみアクセス可能\n・protected：同じクラスと継承先からアクセス可能\n\n利点：\n・データの整合性を保つ\n・実装の詳細を隠蔽\n・変更の影響範囲を限定',
        '【継承（Inheritance）】\n既存のクラス（親クラス・スーパークラス）の特性を引き継いで、新しいクラス（子クラス・サブクラス）を作成する仕組みです。\n\n特徴：\n・コードの再利用性向上\n・is-a関係の表現（例：犬 is-a 動物）\n・共通部分を親クラスにまとめる\n\nオーバーライド：\n・親クラスのメソッドを子クラスで再定義\n・子クラス独自の振る舞いを実装',
        '【ポリモーフィズム（多態性）】\n同じインターフェースで異なる実装を持つことができる性質です。\n\n種類：\n・オーバーロード：同名メソッドを引数の型や数で区別\n・オーバーライド：継承関係での同名メソッドの再定義\n・インターフェース：共通の操作を定義し、実装は各クラスで行う\n\n利点：\n・柔軟なプログラム設計\n・拡張性の向上\n・コードの簡潔性',
        '【抽象化（Abstraction）】\n重要な部分だけを取り出し、詳細を隠す概念です。\n\n抽象クラス：\n・インスタンス化できないクラス\n・共通の属性やメソッドを定義\n・一部のメソッドは実装なし（抽象メソッド）\n\nインターフェース：\n・メソッドのシグネチャのみを定義\n・実装は各クラスで行う\n・多重継承の代替手段',
        '【オブジェクト指向の利点】\n・モジュール性：機能を独立した部品として管理\n・再利用性：既存のクラスを活用して開発効率向上\n・保守性：変更の影響範囲を限定\n・拡張性：新機能の追加が容易\n・理解しやすさ：現実世界のモデル化'
      ],
      examples: [
        {
          title: 'クラスとオブジェクトの例',
          code: `// クラスの定義
class Car {
    // 属性（フィールド）
    private String color;
    private int speed;
    private String model;
    
    // コンストラクタ
    public Car(String color, String model) {
        this.color = color;
        this.model = model;
        this.speed = 0;
    }
    
    // メソッド
    public void accelerate() {
        speed += 10;
    }
    
    public void brake() {
        if (speed > 0) {
            speed -= 10;
        }
    }
    
    // ゲッター
    public int getSpeed() {
        return speed;
    }
}

// オブジェクトの生成と使用
Car myCar = new Car("red", "Toyota");
myCar.accelerate();  // speed = 10
myCar.accelerate();  // speed = 20
System.out.println(myCar.getSpeed());  // 20`,
          explanation: 'Carクラスから複数の車オブジェクトを作成でき、それぞれが独立した状態を持ちます。'
        },
        {
          title: '継承とポリモーフィズムの例',
          code: `// 親クラス
class Animal {
    protected String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void makeSound() {
        System.out.println("動物の鳴き声");
    }
}

// 子クラス1
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + "：ワンワン！");
    }
}

// 子クラス2
class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + "：ニャー！");
    }
}

// ポリモーフィズムの活用
Animal[] animals = {
    new Dog("ポチ"),
    new Cat("タマ"),
    new Dog("ハチ")
};

for (Animal animal : animals) {
    animal.makeSound();  // それぞれの動物に応じた鳴き声
}`,
          explanation: '同じmakeSound()メソッドでも、実際のオブジェクトの型に応じて異なる動作をします。'
        }
      ],
      keyPoints: [
        'オブジェクト指向は「もの」中心の設計手法',
        'カプセル化でデータを保護し、実装を隠蔽',
        '継承でコードを再利用し、階層構造を表現',
        'ポリモーフィズムで柔軟な設計を実現',
        '大規模開発において保守性と拡張性を向上'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: 'カプセル化の目的として適切でないものはどれか。',
        options: [
          'データの整合性を保つ',
          '実装の詳細を隠蔽する',
          '処理速度を向上させる',
          '変更の影響範囲を限定する'
        ],
        correctAnswer: 2,
        explanation: 'カプセル化の主な目的は、データの保護と実装の隠蔽です。処理速度の向上は直接的な目的ではありません。'
      },
      {
        id: 'q2',
        question: '継承関係を表す適切な例はどれか。',
        options: [
          '車 has-a エンジン',
          '学生 is-a 人間',
          '会社 uses-a 従業員',
          '本 contains-a ページ'
        ],
        correctAnswer: 1,
        explanation: '継承はis-a関係を表します。「学生は人間である」という関係が継承に適しています。has-aは集約関係を表します。'
      }
    ]
  },
  'uml': {
    id: 'uml',
    title: 'UML',
    content: {
      overview: 'UML（Unified Modeling Language：統一モデリング言語）は、ソフトウェアの設計を視覚的に表現するための標準的な記法です。システムの構造や振る舞いを図で表すことで、開発者間のコミュニケーションを円滑にします。',
      details: [
        '【UMLとは】\nUMLは、オブジェクト指向分析・設計のための標準化された図式表現です。\n\n特徴：\n・国際標準規格（ISO/IEC 19501）\n・視覚的にシステムを表現\n・開発者間の共通言語\n・設計の文書化\n\n主な用途：\n・要求分析\n・システム設計\n・実装の指針\n・保守・改修の参考資料',
        '【クラス図】\nシステムの静的な構造を表す最も基本的な図です。\n\nクラスの表記：\n┌─────────────┐\n│ クラス名     │\n├─────────────┤\n│ 属性        │\n├─────────────┤\n│ メソッド     │\n└─────────────┘\n\nアクセス修飾子：\n・+ : public\n・- : private\n・# : protected\n\n関係の種類：\n・関連（Association）：──\n・集約（Aggregation）：◇──\n・コンポジション（Composition）：◆──\n・継承（Inheritance）：──▷\n・実装（Realization）：- - ▷',
        '【シーケンス図】\nオブジェクト間のメッセージのやり取りを時系列で表す図です。\n\n構成要素：\n・ライフライン：オブジェクトの生存期間\n・メッセージ：オブジェクト間の通信\n・活性区間：オブジェクトが活動中の期間\n・返却メッセージ：処理結果の返却\n\nメッセージの種類：\n・同期メッセージ：→（実線矢印）\n・非同期メッセージ：→（実線矢印、斜め）\n・返却メッセージ：← - -（破線矢印）',
        '【ユースケース図】\nシステムの機能要件を利用者の視点から表現する図です。\n\n構成要素：\n・アクター：システムの利用者（人型アイコン）\n・ユースケース：システムの機能（楕円）\n・システム境界：対象システムの範囲（四角形）\n\n関係：\n・関連：アクターとユースケースの関係\n・包含（include）：必ず実行される関係\n・拡張（extend）：条件付きで実行される関係\n・汎化：継承関係',
        '【状態遷移図】\nオブジェクトの状態変化を表す図です。\n\n構成要素：\n・状態：オブジェクトの状態（角丸四角形）\n・遷移：状態の変化（矢印）\n・開始状態：●（黒丸）\n・終了状態：◉（二重丸）\n・イベント：状態遷移のきっかけ\n・ガード条件：遷移の条件\n・アクション：遷移時の処理',
        '【その他の主要な図】\nアクティビティ図：\n・処理の流れを表現\n・フローチャートに似た表記\n・並行処理も表現可能\n\nコンポーネント図：\n・システムの物理的な構成\n・コンポーネント間の依存関係\n\n配置図：\n・ハードウェア構成\n・ソフトウェアの配置\n\nオブジェクト図：\n・特定時点のオブジェクトの状態\n・クラス図のインスタンス'
      ],
      examples: [
        {
          title: 'クラス図の例',
          code: `┌─────────────────┐
│    Animal       │  親クラス
├─────────────────┤
│ - name: String  │
│ - age: int      │
├─────────────────┤
│ + eat(): void   │
│ + sleep(): void │
└─────────────────┘
         △
         │ 継承
    ┌────┴────┐
    │         │
┌─────────┐ ┌─────────┐
│   Dog   │ │   Cat   │  子クラス
├─────────┤ ├─────────┤
│         │ │         │
├─────────┤ ├─────────┤
│+ bark() │ │+ meow() │
└─────────┘ └─────────┘

// 関連の例
┌─────────┐      ┌─────────┐
│Student  │ 1..* │ Course  │
│         ├──────┤         │
└─────────┘      └─────────┘
学生は複数の科目を履修できる`,
          explanation: 'クラス図では、クラスの構造と関係を視覚的に表現します。継承、関連、多重度などを明確に示せます。'
        },
        {
          title: 'シーケンス図の例',
          code: `  利用者      ATM        銀行システム
    │         │              │
    │ カード挿入│              │
    ├────────→│              │
    │         │ 認証要求      │
    │         ├─────────────→│
    │         │              │認証処理
    │         │   認証OK      │
    │         │←- - - - - - -│
    │ 金額入力 │              │
    ├────────→│              │
    │         │ 出金要求      │
    │         ├─────────────→│
    │         │              │残高確認
    │         │   出金OK      │
    │         │←- - - - - - -│
    │  現金   │              │
    │←────────│              │
    │         │              │`,
          explanation: 'シーケンス図は、時系列でオブジェクト間のやり取りを表現し、処理の流れを理解しやすくします。'
        }
      ],
      keyPoints: [
        'UMLはソフトウェア設計の標準的な記法',
        'クラス図で静的構造、シーケンス図で動的振る舞いを表現',
        'ユースケース図で機能要件を整理',
        '状態遷移図でオブジェクトの状態変化を表現',
        '図を使うことで設計の共有と理解が容易になる'
      ]
    },
    quiz: [
      {
        id: 'q1',
        question: 'UMLのクラス図で、privateを表すアクセス修飾子の記号はどれか。',
        options: [
          '+',
          '-',
          '#',
          '*'
        ],
        correctAnswer: 1,
        explanation: 'UMLのクラス図では、- (マイナス)がprivate、+ (プラス)がpublic、# (シャープ)がprotectedを表します。'
      },
      {
        id: 'q2',
        question: 'システムの機能要件を利用者の視点から表現するUML図はどれか。',
        options: [
          'クラス図',
          'シーケンス図',
          'ユースケース図',
          '状態遷移図'
        ],
        correctAnswer: 2,
        explanation: 'ユースケース図は、アクター（利用者）の視点からシステムの機能要件を表現する図です。'
      }
    ]
  }
}